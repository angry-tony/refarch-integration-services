# Customer Management RESTful micro service
This project is part of the 'IBM Data Analytics Reference Architecture' solution, available at [https://github.com/ibm-cloud-architecture/refarch-analytics](https://github.com/ibm-cloud-architecture/refarch-analytics) and the specific Customer churn solution describes in [refarch-cognitive-analytics public github](https://github.com/ibm-cloud-architecture/refarch-cognitive-analytics)

Updated 1/10/2018.

The goal of this project is to implement a set of RESTful services to manage customer and purchase order.

## Target audience
* Architects who want to understand the components involved and the architecture constraints and design considerations
* Developers who want to get starting code, and educate themselves on the related technologies

## Table of Contents
* [Code explanation](#code-explanation)
* [API definition](#api-definition)
* [Build and deploy](#build-and-deploy)
* [Install on ICP](#ibm-cloud-private-deployment)
* [Test Driven Development](#test-driven-development)


## Code Explanation
This micro services is using JAXRS to expose RESTful APIs for all basic operations on the customer and account entities. There are a lot of articles on how to develop a RESTful application using JAXRS, we will not rewrite everything, but we still want to present the steps we followed, it can be used as a cheat sheet.
### Customer resource
Created a Customer resource Java class and add JAXRS annotations to define the URL paths and the swagger documentation:
 ```java
@Path("/customers")
@Api("Customer management micro service API")
	public class CustomerResource {
	   //...
	  @GET
		@Path(value="/{id}")
		@ApiOperation(value = "Get customer and his/her account with ID")
		@Produces(MediaType.APPLICATION_JSON)
		@ApiResponses({ @ApiResponse(code = 200, message = "Customer retrieved", response = CustomerAccount.class),
			@ApiResponse(code = 404, message = "Customer not found") })
		public Response getCustomerById(@PathParam("id")long id) throws DALException{
			logger.warning((new Date()).toString()+" Get Customer "+id);
			Customer c = customerDAO.getCustomerById(id);
			if (c != null) {
				return Response.ok().entity(new CustomerAccount(c)).build();
			} else {
				return Response.status(Status.NOT_FOUND).build();
			}
    }
	}
  // ... other operations not shown
  ```

  To automatically generate the swagger file you need the following swagger-annotation jar in your classpath (we deliver one in the lib folder) and use the `@Api, @ApiResponse, @ApiOperation` annotations. When deploying on Liberty server the swagger is autogenerated.

 The app is packaged and exposed with a web context set to `caseserv`. The web.xml map the URL: `/api/v1/*` to the servlet managing the resources.  Therefore the customer resource will be at the url: `http://hostname:port/caseserv/api/v1/customers`.
 The above annotations exposes the method getCustomerById to a HTTP GET on the above URL with the customer id as suffix. The chosen implementation is to use the Response object to control return code and the payload. We could have returned the Customer data directly too.

 Also we are not exposing the Customer object as is: the Customer is a JPA entity mapped to a CUSTOMER table in the database, we want to build a view of the data needed by the consumers of the service. The CustomerAccount is a Data Transfer Object pattern. It may not be the best view but we may refactor it later when requirements will add up.

### Data model
The entity data model to support is presented in the figure below. It is similar to the tables in backend database. The java classes have JPA annotations to control the persistence and management of the relationship, persistence strategy and loading strategy.

 ![](docs/DomainModel.png)

 The CustomerAccount data transfer object is a view of the persistence model. It does not present a best practice, but it is good enough from now.

 ![](docs/CustomerDTO.png)

We also delivered SQL statements and scripts to create the database in DB2. See the folder `db-scripts`.

### JAXRS application

Develop the application definition with the class `RAIntegrationApplication` which declares the exposed resources:

```java
import javax.ws.rs.core.Application;
import io.swagger.annotations.SwaggerDefinition;
import io.swagger.annotations.Tag;

	@ApplicationPath("/caseserv")
	@SwaggerDefinition(tags= {@Tag(name = "Customer API",description=" JAXRS API for customer management micro service")})
	public class RAIntegrationApplication extends Application {
			@Override
			public Set<Class<?>> getClasses() {
				Set<Class<?>> classes = new HashSet<Class<?>>();
				classes.add(CustomerResource.class);
        classes.add(AccountResource.class);
			}
			// ..
    }
  ```

### Web app descriptors
Specify the url mapping to the pre-defined servlet serving REST resources in the web.xml:
```xml
<servlet>
 <description>
 Main servlet entry point for the REST resource/application</description>
 <servlet-name>JAX-RS Servlet</servlet-name>
 <servlet-class>com.ibm.websphere.jaxrs.server.IBMRestServlet</servlet-class>
 <init-param>
   <param-name>javax.ws.rs.Application</param-name>
   <param-value>ibm.ra.integration.RAIntegrationApplication</param-value>
 </init-param>
 <load-on-startup>1</load-on-startup>
 <enabled>true</enabled>
 <async-supported>false</async-supported>
</servlet>
<servlet-mapping>
 <servlet-name>JAX-RS Servlet</servlet-name>
 <url-pattern>/api/v1/*</url-pattern>
</servlet-mapping>
```

### Data Access Objects

Implement the different DAOs to access the database. We are using a pure Java Persistence API implementation. We defined a BaseDAO for generic persistence operations like save, update, delete... Each DAO supports a specific entity and its CRUD operations.
The following code example illustrates  typical JPA pattern of using predefined query defined at the entity level in the customer class:

```
@Entity(name="Customer")
@Table(name="CUSTOMERS")
@NamedQuery(name="Customer.findAll", query="SELECT c FROM Customer c")
public class Customer extends Party{
```
In the DAO implementation for the "get the list of customers" method, we use the JPA entity manager and create an instance of the query:

```
@Override
public Collection<Customer> getCustomers() throws DALException {
  EntityManager em = getEntityManager();
  List<Customer> results = new ArrayList<Customer>();
  try{
    Query query =em.createNamedQuery("Customer.findAll");
    results = query.getResultList ();

  } finally {
    em.close();
  }
  return results;
}
```

### Connect the dots

In the resource class delegates calls to the DAO. Implement any business logic in the service. We did not decouple the API class from the service where the business logic can be done and tested in isolation. It is recommended to do this refactoring in the future.


### API definition
With Liberty it is possible to visualize the API definition for a deployed JAXRS resource. The product documentation is [here](), but to summarize we did two things:
* define a yaml file for the swagger and save it to webapp/META-INF/stub folder.
* modify the server.xml to add api discovery feature.
```
        <feature>apiDiscovery-1.0</feature>
```

Once the service is deployed locally or on remote server using the URL http://localhost:9080/api/explorer/#/Customer_management_micro_service_API will display the API as you can see below:

![](docs/customer-api.png)

We also developed a `swagger.yaml` file in the folder `src/main/webapp/META-INF/stub` to describe the APIs. This may be helpful for defining an API product in API Connect.

## Build and Deploy

### DB2 CUSTDB database
For the DB2 read [this note](docs/DB2Creation.md)

### Micro Service Java Code
The project was developed with [Eclipse Neon](http://www.eclipse.org/neon) with the following plugins added to the base eclipse:
* Websphere Developer Tool for Liberty: using the Marketplace and searching WebSphere developer, then use the Eclipse way to install stuff.
* Gradle eclipse plugin

Install `gradle CLI` on your computer so you can build, unit test and assemble war.  For that see the installation instructions at [gradle](http://gradle.org)

To build the code you can use maven `nvm install` or gradle: `./gradlew build`. The `build.gradle` script should compile, unit tests and build a war under `build/libs` folder.

### Dockerize
Then use the `docker build -t ibmcase/customerms .` command to build a docker image which includes WebSphere liberty, the server configuration, and the war file pre deployed in the app folder.

You can test locally using `docker run -p 9080:9080 ibmcase/customerms` and then points your web browser to `http://localhost:9080/caseserv/index.html`. If the front end page is loaded your configuration works!.

We also added some integration tests under the package `ibm.caseserv.itests` folder.

## IBM Cloud Private deployment
We are following the same approach as the other micro service deployment we do at http://github.com/ibm-cloud-architecture, for example the [Case web app](https://github.com/ibm-cloud-architecture/refarch-caseinc-app/blob/master/docs/icp/README.md) or the [Data Access layer](https://github.com/ibm-cloud-architecture/refarch-integration-inventory-dal/blob/master/docs/icp/README.md) projects.
* dockerize the application with Liberty: a Dockerfile is delivered as part of this project. See previous section.
* Tag the docker images with the name of the remote docker repository, the target namespace and the name and version of the image. For example: `greencluster.icp:8500/greencompute/customerms:v0.0.1`
* docker login to remote repo: `docker login greencluster.icp:8500`
* docker push the newly created image to the remote repository: `docker push greencluster.icp:8500/greencompute/customerms:v0.0.1`
* define helm charts with deployment configuration: the chart definition is under chart/green-customerms
* use `kubectl` to access the remote Kubernetes cluster and `helm` CLI to deploy the helm chart and work on the deployed pod.

## Test Driven Development
### Validating DAO / JPA
To implement the DAO we start by specifying the DAO interface  and then implemented the unit tests or each method, before coding the JPA code. The junit tests are in the package `dao.jpa.ut` under the folder `src/test/java`.

The test has a specific persistence configuration that uses derby embedded so it is easy to delete the DB after the tests. The persistence.xml is under `src/test/resources/META-INF` folder.
```xml
<persistence-unit name="customer" transaction-type="RESOURCE_LOCAL">
 <provider>org.apache.openjpa.persistence.PersistenceProviderImpl</provider>
   <class>po.model.Party</class>
   <class>po.model.Customer</class>
   <class>po.model.Account</class>
 <properties>
 <property name="javax.persistence.jdbc.driver" value="org.apache.derby.jdbc.EmbeddedDriver"/>
```
The `BaseTest` has an AfterClass method to delete the database.

When running the test in Eclipse be sure to add to the vm arg of each test, the following `-javaagent:./lib/openjpa-all-2.4.2.jar` to get the entities JPA enhanced. The figure below presents the setting in eclipse `run configuration`:  

![](docs/jpa-enhance-ut.png)

Also as we are using a dedicated `persistence.xml` to use derby for unit testing, it is important to modify the classpath of the `run configuration` and reference the test resource folder: select the `User Entries`, then `Advanced` button, select `Add folders`, and select test `src/test/resources` folder, then finally be sure it is above the default classpath, using `Up` to order it.  

![](docs/cp-ut-jpa.png)

### Populating Customer database
When connected to the test or staging platform it is recommended to use our data sets to prepare data for the machine learning / analytics future work. The folder dataset has 2 csv files. The customer.csv has 10 records, it should be used to validate the deployment, and everything works fine. The customer_churn.csv has all the remaining records.
